!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
A	test_b2.py	/^A = br.SpikeGeneratorGroup(N=2, indices=np.array([0, 1]), times=np.array([0.05, 0.74])*br.ms)$/;"	v
A	xor.py	/^A=0.02 \/ 1000$/;"	v
B	xor.py	/^B=0.2 \/ 1000$/;"	v
C	xor.py	/^C=-65.0 \/ 1000$/;"	v
CheckNumSpikes	snn.py	/^        S_in, S_hidden, S_out, train=False, letter=None):$/;"	f
CollectSpikes	snn.py	/^def CollectSpikes(N_hidden, S_hidden, S_out):$/;"	f
D	xor.py	/^D=6.0 \/ 1000$/;"	v
DesiredOut	train.py	/^def DesiredOut(label, bench):$/;"	f
GetInSpikes	snn.py	/^def GetInSpikes(img, bench='LI'):$/;"	f
L	train.py	/^def L(t):$/;"	f
LoadConnectivity	snn.py	/^def LoadConnectivity(Si, Sl, Sa, Sb, number):$/;"	f
LowPass	snn.py	/^def LowPass(S):$/;"	f
M	xor.py	/^M =br.StateMonitor(output_neurons,'ge',record=0)$/;"	v
ModifyWeights	snn.py	/^def ModifyWeights(S, dv, rand=0):$/;"	f
Mu	xor.py	/^Mu=br.StateMonitor(output_neurons,'u',record=0)$/;"	v
Mv	xor.py	/^Mv=br.StateMonitor(output_neurons,'v',record=0)$/;"	v
N	xor.py	/^    N = 0  # Number of filters$/;"	v
N	xor.py	/^    N = 1$/;"	v
N	xor.py	/^N = 1$/;"	v
N	xor.py	/^N =br.StateMonitor(hidden_neurons,'ge',record=0)$/;"	v
N_h	xor.py	/^N_h = 1$/;"	v
N_hidden	xor.py	/^N_hidden = 4$/;"	v
N_in	xor.py	/^N_in = 2$/;"	v
N_liquid	xor.py	/^N_liquid = [3, 3, 14]$/;"	v
N_o	xor.py	/^N_o = 1$/;"	v
N_out	xor.py	/^N_out = 1$/;"	v
Nu	xor.py	/^Nu=br.StateMonitor(hidden_neurons,'u',record=0)$/;"	v
Nv	xor.py	/^Nv=br.StateMonitor(hidden_neurons,'v',record=0)$/;"	v
P_Index	snn.py	/^def P_Index(S_d, S_l):$/;"	f
P_Index	train.py	/^def P_Index(S_l, S_d):$/;"	f
Pc	xor.py	/^Pc = 0.005$/;"	v
PickWeightIndexA	train.py	/^def PickWeightIndexA(Sa, S_hidden, S_out):$/;"	f
PickWeightIndicesB	train.py	/^def PickWeightIndicesB(Mv, Sb, S_hidden, S_out, d_i=3):$/;"	f
Plot	snn.py	/^def Plot(Mv, number):$/;"	f
PrintSpikes	snn.py	/^        S_in, S_hidden, S_out, train=False, letter=None):$/;"	f
ReSuMe	train.py	/^        hidden_neurons, output_neurons, Si, Sl, Sa, Sb, M, Mv, Mu, S_in, S_hidden, S_out):$/;"	f
ReadImg	snn.py	/^def ReadImg(number=1, letter=None, bench='LI', levels=None):$/;"	f
Run	snn.py	/^        S_in, S_hidden, S_out, train=False, letter=None):$/;"	f
S_hidden	xor.py	/^S_hidden = br.SpikeMonitor(hidden_neurons, record=True)$/;"	v
S_in	xor.py	/^S_in = br.SpikeMonitor(input_neurons, record=True)$/;"	v
S_out	xor.py	/^S_out = br.SpikeMonitor(output_neurons, record=True)$/;"	v
Sa	xor.py	/^Sa = br.Synapses(liquid_out, hidden_neurons, model=synapse_model, pre=synapse_pre)#, max_delay=9*br.ms)$/;"	v
SaveConnectivity	snn.py	/^def SaveConnectivity(Si, Sl, Sa, Sb, number):$/;"	f
Sb	xor.py	/^Sb = br.Synapses(hidden_neurons, output_neurons, model=synapse_model, pre=synapse_pre)$/;"	v
SetNumSpikes	snn.py	/^        S_in, S_hidden, S_out, train=False, letter=None):$/;"	f
Si	xor.py	/^Si = br.Synapses(input_neurons, liquid_in, model=synapse_model, pre=synapse_pre)#, max_delay=9*br.ms)$/;"	v
Sl	xor.py	/^Sl = br.Synapses(liquid_neurons, liquid_neurons, model=synapse_model, pre=synapse_pre)#, max_delay=9*br.ms)$/;"	v
SpikeSlopes	train.py	/^def SpikeSlopes(Mv, S_out, d_i=3):$/;"	f
T	xor.py	/^T = 20$/;"	v
TAU	xor.py	/^TAU=15.0 \/ 1000$/;"	v
TestNodeRange	train.py	/^        Si, Sl, Sa, Sb, M, Mv, Mu, S_in, S_hidden, S_out):$/;"	f
WeightChange	train.py	/^def WeightChange(s):$/;"	f
a	xor.py	/^a = A\/br.second$/;"	v
b	xor.py	/^b = B$/;"	v
bench	xor.py	/^bench = bench$/;"	v
bench	xor.py	/^bench='xor'$/;"	v
c	xor.py	/^c = C*br.volt$/;"	v
count	xor.py	/^count = 0$/;"	v
d	xor.py	/^d = D*br.volt$/;"	v
dWa	train.py	/^def dWa(Sa, v_diffs, i_diffs):$/;"	f
d_w	snn.py	/^def d_w(S_d, S_l, S_in):$/;"	f
data_dir	xor.py	/^    data_dir = 'noise\/'$/;"	v
data_dir	xor.py	/^    data_dir = 'on_pyr\/'$/;"	v
desired	xor.py	/^        desired = desired_times[0]$/;"	v
desired	xor.py	/^        desired = desired_times[1]$/;"	v
desired_times	xor.py	/^    desired_times = [-1, -1]$/;"	v
diff	xor.py	/^    diff = extreme_spikes[1] + extreme_spikes[0]$/;"	v
diff_r	xor.py	/^    diff_r = diff \/ 8.0$/;"	v
dir	xor.py	/^    dir = 'li-data\/'$/;"	v
dir	xor.py	/^    dir = 'minst\/'$/;"	v
extreme_spikes	xor.py	/^            Si, Sl, Sa, Sb, M, Mv, Mu, S_in, S_hidden, S_out)$/;"	v
g	xor.py	/^g = 2$/;"	v
hidden_neurons	xor.py	/^        refractory=2*br.ms, reset=reset_t)$/;"	v
img	xor.py	/^img = np.empty(img_dims)$/;"	v
img_dims	xor.py	/^    img_dims = (1, 2)$/;"	v
img_dims	xor.py	/^    img_dims = (n, n)$/;"	v
input_neurons	xor.py	/^input_neurons = br.SpikeGeneratorGroup(N=N_in+1, indices=np.array([]), times=np.array([])*br.ms)$/;"	v
levels	xor.py	/^    levels = 1$/;"	v
levels	xor.py	/^    levels = levels$/;"	v
levels	xor.py	/^levels=4$/;"	v
liquid_hidden	xor.py	/^liquid_hidden = br.Subgroup(liquid_neurons, N_liquid[0], N_liquid[-1] - N_liquid[1])$/;"	v
liquid_in	xor.py	/^liquid_in = br.Subgroup(liquid_neurons, 0, N_liquid[0])$/;"	v
liquid_neurons	xor.py	/^        refractory=2*br.ms, reset=reset_t)$/;"	v
liquid_out	xor.py	/^liquid_out = br.Subgroup(liquid_neurons, N_liquid[-1] - N_liquid[1], N_liquid[-1])$/;"	v
mid_times	xor.py	/^    mid_times = [-1, -1]$/;"	v
n	xor.py	/^    n = 3   # Dimension of single image (no pyramid)$/;"	v
n	xor.py	/^    n = 32  # Dimension of largest image in pyramid$/;"	v
number	xor.py	/^number = 1 #number of hidden_neurons$/;"	v
number	xor.py	/^number = 3$/;"	v
output_neurons	xor.py	/^        refractory=2*br.ms, reset=reset_t)$/;"	v
simtime	xor.py	/^simtime = 1 #duration of the simulation in s$/;"	v
synapse_model	xor.py	/^synapse_model = 'w:1'$/;"	v
tau	xor.py	/^tau = TAU*br.second$/;"	v
thresh	xor.py	/^thresh='v>vt'$/;"	v
u0	xor.py	/^u0 = B*v0$/;"	v
v0	xor.py	/^v0 = (br.volt*br.sqrt((((5 - B) \/ 0.08)**2-140) \/ 0.04) - br.volt*((5 - B) \/ 0.08)) \/ 1000.0$/;"	v
vr	xor.py	/^vr = -74 * br.mV$/;"	v
vt	xor.py	/^vt = -15 * br.mV$/;"	v
